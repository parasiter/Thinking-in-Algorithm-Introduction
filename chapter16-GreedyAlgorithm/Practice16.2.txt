16.2-1 证明：分数背包问题具有贪心选择性质？
即证明1、具有最优子结构，2、贪心选择总是安全的
对于性质1，每次做选择时，选择剩余商品中性价比最高的商品，作为贪心选择ak，然后剩余的子问题为Sij，即证明Sij = ak + S[i,k]+S[k,j]成立，假设存在更优的选择aj，Sij = am + S[i,m]+S[m,j]，此时做出贪心选择时，当前的最优选择为ak,不存在比其更优的am，因此分数背包问题具有最优子结构。
对于性质2，贪心选择是安全的，背包问题不依赖与后续子问题的解，因为在后续问题中，总能找到一个最优解来填满背包，不受其他子问题影响。

16.2-2 设计动态规划算法求解0-1背包问题，要求运行时间为O（nw）,n为商品数量，w是背包的最大商品总重量。
本题与动态规划的思考题15-12形式完全一样，伪代码略，见15章consider_question

16.2-3 假定在0-1背包问题中，商品的重量递增序与价值递减序完全一样，设计一个高效算法，求此背包问题的变形最优解，证明你的算法是正确的。
如果商品的重量递增序与价值递减序完全一样，那么本题可以用贪心算法来解决。
直接不断选择性价比最高的物品即可。
在0-1情况下，最终的结果受商品重量和价值两者决定，当改为分数背包时，相当于重量因素被抛弃，因此仅受一个价值因素影响，可用贪心算法解决，同样的，在本题中，当商品的重量递增序与价值递减序完全一样时，重量和价值两因素完全相关，可用其中任意一个因素代替两因素，最终结果可视为仅受一个因素影响，可用贪心算法解决。

16.2-4 题目长，略
假设1,2...n表示起点之后的第几个点，A[n]保存第i个点与第i-1个点之间的距离，伪代码如下
GREEDY-SELECT(A,n)
{
	array b[n];//保存补充水的点
	count = 0 ;//距离
	for(i=1;i<=n;i++)
	{
		count += A[i];
		if(count>m)
			b[i-1] = 1;
			count = A[i];
	}
	return sum(b[n]);
}
贪心算法，每次都在水恰好不够的前一个站点补充水源。

16.2-6 设计算法，在O（n）时间内求解分数背包问题。
若要在0（n）时间内求解分数背包问题，那么就意味着遍历O（1）次商品，就能得到最佳方案，伪代码如下：
ADJUST-BAG(A,n,m)
{
	list b;//用链表来链接包中的商品,每个元素属性包括weight，price,pre,next
	b.next = nil,b.uprice = 0;
	for(i=1;i<=n;i++)
	{	
		j = b;
		q = j;
		while(j!=nil)
		{	
			q = j;//保存j的上一个元素
			if(A[i].uprice>j.uprice）
				insert(A[i],j);//如果A[i]的性价比高于包中某个物品，则将A[i]插入到该位置，其余物品后移
				cut(b,m);//如果商品的总重量大于m，则将链表物品总重量大于m以后的商品截断丢弃
				break;
			else j = j.next;
		}
		if(j ==nil)
			q.next = A[i];
			cut(b,m);
	}
	return b;	
}
insert(A,b)
{
	b.pre.next = A;
	A.pre = b.pre;
	A.next = b;
	b.pre = A;
}
cut(b,m)
{
	k = 0;
	j = b.next
	while(b!=nil&&k<=m)
	{
		j=j.next;
		k+=b.weight;
	}
	if(b==nil)
		return;
	else
	{
		j.price = (j.weight - (k-m))*j.price/j.weight;	  
		j.weight = j.weight - (k-m);
		j.next = nil;
		return b;
	}
}
上述代码只遍历所有商品一次，即可取得最优解，其策略为将包内的商品按性价比从大到小排序，每当取得一个商品，判断其在包中的位置，插入其中，其余商品后移，超过包承重m的部分就丢弃。此算法默认包中最多仅有O（1）个商品。
		
	
	

16.2-7 给定两个集合，各包含n个正整数，你可以按照任意重排每个集合。重排后，令ai为集合A的第i个元素，bi为集合b的第i个数，于是你得到回报π(ai^bi）,设计算法最大化你的回报，证明你的算法是正确的。
对于递增序列A[n]和递增序列B[n]可以得到最大回报，
当A[n]和B[n]是递增序列时，假设i<j，很容易证明(ai^bi)*(aj^bj) > (ai^bj)*(aj^bi),直接相除即可。
然后，假设A已经排成递增序，当B为乱序时，可以通过K次逆序对转换成递增序B'，因此通过上述证明结果可知A,B均为递增序时更大，同样，可以继续推广到A,B的任何序均小于A,B为递增序时的最大回报。因此，伪代码即为对序列A和B的排序。运行时间O（nlgn）



