16-1 （找零问题） 考虑用最少的硬币找n美分的问题。假定每种硬币的面额都是整数。
a. 设计贪心算法求解找零问题，假定有25美分，10美分，5美分和1美分4种面额的硬币。证明你的算法能找到最优解。
贪心算法每次选取当前能用的最大面额纸币。
证明该算法具有贪心性质，即证明当前选择必然包含在最优解中。
4种纸币为a1,a2,a3,a4,分别代表25美分，10美分，5美分和1美分，并且每一个较大值的面额，可由几个较小值面额的硬币组成。
对于找零n美分的问题，x是当前满足小于n的最大面额硬币，假设包含x的集合为A。
假设不存在这样的x，令x?B，且B是一个最优解，则当前选择另一个面额y，存在x>y,A剩余美分为n-x，B中剩余美分为n-y,则n-x<n-y，继续取的话，必定存在N(n-x)<=N（n-y）,因此A也是一个最优解，且包含x

b. 假定硬币面额是c的幂，即面额为c^0,c^1,...c^k，c和k为整数，c>1,k>=1.证明：贪心算法总能得到最优解。
以面额为c^0,c^1,...c^k的硬币，对于任何i<j的i值，c^j面额可由多个c^i面额的硬币组成，因此贪心算法总能得到最优解。

c. 设计一组硬币面额，使得贪心算法不能保证得到最优解，这组硬币面额中应该包含1美分，使得对于每个零钱都存在找零方案。
例如硬币面额10,9,8,2,1
当找零值为17时，贪心算法得到的解为10,2,2,2,1
而最优解为9,8 。此时贪心算法明显没有得到最优解

d. 设计一个O（nk）时间的找零算法，适用于任何k种不同面额的硬币，假定总是包含1美分硬币。
动态规划可以用于任何K中不同面额硬币的找零算法，如果按照常规思路，其运行时间为O（n^2）。
现在从动态规划的角度思考，因为存在n个子问题，外层循环为n次，不会改变。要想使时间复杂度降为O（nk）,应该只能从内层循环下手，即解决每个子问题，只需O（k）次，也就是每次仅存在k次划分。确实没想出来。

16-2（最小平均完成时间调度问题） 假定给定任务集合S = {a1,a2...an}，其中任务ai在启动后需要pi个时间完成。每个时刻只能进行一个任务。令ci表示任务ai的完成时间，即任务ai被执行完的时间。你的目标是最小化平均完成时间，即最小化(1/n)∑ci（i∈[1,n]）。
a. 设计算法，求平均完成时间最小的调度方案。任务的执行都是非抢占的，即一旦ai开始运行，它就持续运行pi个时间单位。证明你的算法能最小化平均时间，并分析算法的运行时间。
平均时间为T=(1/n)∑ci， ci = ∑pj（j∈[1,i]）=> T = n*p1+(n-1)p2+...pn，则最优解T对应的任务顺序为sort（ai）by increase pi
因此本题可以使用贪心算法解决问题，当前选择的任务i为剩余任务中完成时间最小的。证明如下：
假设一个最优选择，当前选择的任务为j，则有pj>=pi,i<j,其完成时间为T' = ...(n-i) pj+...+（n-j）pi...
T-T' = (i-j)(pj-pi)<=0，因此T也是一个最优解。
因此算法仅消耗一个排序的O（nlgn）的时间。

b. 现在假定任务并不是在任意时刻都可以开始执行，每个任务都有一个释放时间ri,在此时间之后才可以开始。此外假定任务执行都是可以抢占的，这样任务可以被挂起，稍后再重新开始。设计算法，对此问题求解平均时间的最小的调度方案。
此问题可以转换成问题a，因此贪心算法同样适用，具体解决策略如下：
每次选择当前释放时间下，可选的最小完成时间任务，并且如果任务面临被抢占时，将原来任务切割成两个任务，其完成时间为q1,q2，将q2插入到候选任务中，选择其中最小任务执行。证明如下：
T = n*p1+(n-1)p2+...pn，假设当前选择任务为ai,则
T' = ..(n-i)pi+... = (n-i)q1+（n-i）q2...,由于子任务q1受释放时间限制，因此只能考虑q2之后的元素集合，剩余证明过程同a，可以证明是最优选择。
算法运行时间为O（n^2），对数组以pi排序需要nlgn,每次从排序后的集合中调取符合释放时间的任务需要O（n），循环运行O（n）次，因此，算法运行时间为O（n^2）

16-3（无环子图）
a. 一个无向图G=（V,E）的关联矩阵是一个|V|×|E|的矩阵M，若边e关联与顶点v,则Mve = 1,否则Mve = 0。论证M的一个列集合在整数模2的域上线性无关当且仅当对应的边集无环。
略。

b. 假定我们对一个无向图G = （V,E）的每条边都关联一个非负权重w(e)。设计一个高效算法，求权重之和最大的无环边集。
无向图G = （V,E）可以形成一个拟阵，Mg = (S,T),其中S为边集E，T为独立子集，题目即求权重最大的集合Q∈T。其伪代码如下：
GREEDY(M,w)
{
	A = ?,
	sort(S) by decreasing w(e)
	for(x∈S)
	{	
		if(A∪{x}∈T)
			A = A∪{x}
	}
	return A;
}

c. 令G = （V,E）是任意的有向图，定义（E,T）满足A∈T，当且仅当A不包含任何有向环，给出一个有向图G的例子，使得关联的系统（E,T）不是一个拟阵。指出定义中哪个条件使得系统（E,T）不是拟阵。
定义三不满足，即交换性质。

这种题，我做不了。。

16-4（调度问题变形）对16.5节中带截止时间和惩罚的单位时间任务调度问题，考虑如下算法。初始时令n个时间槽为空，时间槽i为单位时间长度，结束于时刻i，我们按惩罚值单调递减的顺序处理所有任务。当处理任务aj时，如果存在不晚于aj的截止时间dj的空时间槽，则将aj分配到其中最晚的那个。如果不存在这样的时间槽，将aj分配到最晚的空时间槽。
a.证明此算法总能得到最优解。
本题的根本与拟阵求任务调度问题的算法一样，此算法只是对拟阵任务调度中的伪代码if(A∪{X}∈M.S)给出了一种判断方案，如果存在空槽，则A∪{X}∈M.S,不存在空槽，则A∪{X}? M.S，将X放至末尾，相当于舍弃。

b.利用21.3节提出的快速不相交集合森林来高效实现算法。假定输入任务集合依据按惩罚值单调递减的顺序排序。分析实现程序的运行时间。
此处留坑，待日后看到21章在解决。

16-5（离线缓存）
a. 编写使用将来最远策略的缓存管理器的伪代码。输入时请求序列<r1,r2...rn>和缓存规模k，输出为决策结果序列――处理每个请求时逐出缓存的是哪个数据，分析算法的运行时间。
##我发现这个不是用于离线缓存的
分析可知，应该用队列来处理本问题，当请求在缓存中未保存时，应该将新元素保存至原队首的前一个元素，并将原队尾的元素删除。具体伪代码如下：
CACHE(R,k)
{
	queue A[k];//一个队列结构作为缓存
	for(i=1;i<=R.length;i++)
	{
		for(j = A.head;j>=A.tail;j--)//遍历整个队列
		{
			if(A[j]==R[i])
				swap(A[j],A[A.head])
				print 0
				break;
			elseif(A[j]==nil)
				ENQUEUE(R[i])
				print 0
				break;
			else {
				print A[A.tail]
				DEQUEUE(A[A.tail]);
				ENQUEUE(R[i]);
				break;
			}
		}
	}
}

使用将来最远策略，伪代码如下：
CACHE（R，k）
{
	array A[k];//缓存
	map(x,array[]);//构建一个map，关键字为元素名，值为其在请求中的位置，遍历一次请求即可构建完成。	
	for(i=1;i<=R.length;i++)
	{
		for(j = 1;j<=k;j++)//遍历整个队列
		{
			if(A[j]==nil)
				print 0;
				A[j]=R[i];
				break;
			else {
				X = max(在map中寻找缓存中k个元素的值数组中，第一个大于i的值);//并且对map进行修改，从各个数组中删除小于i的值
				print X;
				A[X] = R[i]	
			}
		}
	}
}
算法外层循环n次,内层循环中，查找最远距离的元素X，对于K中的每个元素耗时O（1）（因为每个距离值就是map(k)返回的数组中当前的第一个元素），max()函数运行时间O（lgk）因此，一共耗时O(nlgk)

b. 证明：离线缓存问题具有最优子结构性质

c. 证明：将来最远策略可以保证最小缓存命中次数
当前选择为最远距离元素X，如果选择距离较小的元素Y，将其逐出，那么在X之前必有一次换出任意元素，换入Y，此后的调度与当初直接换出X是一致的。因此当初不换入wi，使得总交换次数多了一次，可知将来最远策略是最优的。





