16.3-1 请解释，在引理16.2的证明中，为什么若x.freq = b.freq,则有a.freq = b.freq = x.freq = y.freq。
前提为x.freq<=a.freq,y.freq<=b.freq，显然若x.freq = b.freq，则有a.freq = b.freq = x.freq = y.freq

16.3-2 证明：一棵不满的二叉树不可能对应一个最优前缀码。
对于一棵不满的二叉树，那么可以必然存在某结点x，x.left = y,x.right = nil，此时可以令y结点取代x结点，那么以y为根节点的所有子结点（包括y）,其深度均减一。因此一棵不满的二叉树不可能对应一个最优前缀码。

16.3-3 求斐波那契数的最优前缀
斐波那契数列为：1,1,2,3,5,8,13,21...,题目条件为斐波那契数即为其频率，将该数列组成赫夫曼编码时，需要不断比较s(n-1)、F(n)，和F（n+1）的大小。
依据斐波那契数性质，F（n）=F（n-1）+F（n-2）;
则S（n-1）-F（n）= F(n-3)+ F(n-4)....>=0
F(n+1)-S(n-1) = [F(n)-F（n-2）]-F(n-3)...
	      = [F(n-1)-F(n-3)]-F(n-4)...
	      = [F(n-2)-F(n-4)]-F(n-5)...
		....
	      = F(3) - F(1) = 1>=0
因此，每次将s（n-1）插入到序列中时，其始终位于F（n）和F(n+1)之间，下一次始终将F（n）和s（n-1）合并。
因此对于任何n个斐波那契数列，其最优编码为：（n-1）1・0，（n-2）1・0,....,0。

16.3-4 证明：编码树的总代价还可以表示为所有内部结点两个孩子结点的频率之和。
由引理16.3证明得：每当将两个结点合并得到树T’时，B（T）=B（T'）+x.freq+y.freq，此时T'的结点数为T.length -1,
同理可得：B（T'）=B（T''）+x'.freq+y'.freq，此时T''的结点数为T'.length -1,进行n-1次合并后，最后只剩下一个结点。其频率为两子结点的频率之和。
因此，可得B（T）= ∑（x.freq+y.freq），x和y为当前树的最底层根结点的两子结点，而所有根节点在树T中，都是内部结点。得证。

16.3-5 证明：如果我们将字符表中的字符按照频率单调递减排序，那么存在一个最优编码，其码字长度是单调递增的。
码字长度即为字符在编码树中的深度，如果字符按照频率单调递减排序，那么字符在树中的深度必定是单调递增的，可用反证法证明。
假设存在两字符X,Y，X.freq <=Y.freq,且X.h <=Y.h，那么通过交换X,Y位置得到的树T'，必定比树T'更优，此处证明过程同引理16.2.略

16.3-6 假定我们有字母表C = {0,1,...,n-1}上的一个最优前缀码，我们希望用最少的二进制传输此编码。说明如何仅用2n-1+nlgn表示C上的任意最优前缀码。（提示，通过对树的遍历，用2n-1位说明编码树的结构）
题目意思在于如何将一个已知的最优前缀码用最少的内存表示出来。
依据提示，解题思路应该在于先用2n-1表示出树的结构，然后依次用lgn个位来表示每一个叶结点对应的字母。
最优前缀码的树一共有2n-1个结点，表示其结构的伪代码如下：
STRUCTURE(T.root)
{
	x = T.root;
	if(x.right != nil)//满二叉树，只用验证其一个子结点是否存在即可
	{
		print 1;
		STRUCTURE(x.right);
		STRUCTURE(x.left);
	}
	else print 0
}

然后用lgn个位保存一个数，保存n个数需要内存nlgn。
综合上述，一共需要2n-1+nlgn表示C上的任意最优前缀码。

16.3-7 推广赫夫曼算法，使之能生成三进制的码字（即码字由符号0,1,2组成），并证明你的算法能生成最优三进制码。
首先，三进制码的树结构不一定是满的，因为每进行一次结点融合，会导致总结点数-2，推理得，当n为偶数时，非满三叉树。
因此，当n为奇数时，其结构与赫夫曼二叉树结构完全类似，此处省略。
当n为偶数时，考虑到结点融合至最后一层时，T.third = nil,在此处对树的结构进行维护和调整，进行贪心，将下一层中频率的最大者提升至本层，递归至最后一层即可。不过考虑到树的维护过程的根本在于每次将其子结点的最大频率提升至本层，最后结果导致最底层的树只有两个节点。因此可以直接第一次融合低频的三个结点时，只选取两个结点进行融合。伪代码如下：
TERNARY(A,n)
{
	A = min-heap(A);
	if(n%2)
	{
	 	k.first = x = EXTRACT-MIN(Q);
		k.second = y = EXTRACT-MIN(Q);
		k.third = z = nil;
		INSERT(k，A);
		for(i = 1;i<=(n-2)/2;i++)
			k.first = x =EXTRACT-MIN(Q);
			k.second = y = EXTRACT-MIN(Q);
			k.third = z = EXTRACT-MIN(Q);
			k.freq = x.freq +y.freq +z.freq;
			INSERT(k，A);
	}
	else {
		for(i = 1;i<=(n-1)/2;i++)
			k.first = x =EXTRACT-MIN(Q);
			k.second = y = EXTRACT-MIN(Q);
			k.third = z = EXTRACT-MIN(Q);
			k.freq = x.freq +y.freq +z.freq;
			INSERT(k，A);
	}	
	return EXTRACT-MIN(Q);
}

16.3-8 假定一个数据文件由8位字符组成，其中所有256个字符出现的频率大致相同：最高的频率也低于最低频率的两倍。证明，在此情况下，赫夫曼编码并不比8位固定长度的编码更高效;
假设所有字符的频数为p = {k1,k2...kn}
编码所有字符需要内存：8*∑k = O(nK1);
如果用赫夫曼编码，因为每次两个结点融合后，必定形成最大频率，所有叶结点均会几乎全部处在最底层，因此其耗费内存为lg(256)*∑k = O(nk1)
两种方式的渐进运行时间相同。

16.3-9 证明，对于一个由随机生成的8位字符组成的文件，没有任何压缩方法可以将其压缩，哪怕只压缩一位。
随机生成的8位文件，对于每一个字符，其出现的概率均为1/256,即使利用赫夫曼编码，也是形成完全二叉树，叶结点全部落在最底层，每个结点均要占用满满8位。

	


