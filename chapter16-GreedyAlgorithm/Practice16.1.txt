16.1-1 根据递归式（16.2）为活动选择问题设计一个动态规划算法。算法应该按前文定义计算最大兼容活动集的大小c[i,j]并生成最大集本身。假定输入的活动已按公式16.1排好序，比较你的算法和GREEY-ACTIVITY-SELECTOR的运行时间。
动态规划伪代码如下：
DYNAMIC-SELECTOR(s,f,n)
{
	array c[m][m];//c[i][j]保存发生在i到j时间内的最大活动集合
	for(i=1;i<=n;i++)
		c[s[i]][f[i]] =1;//其余置为0，略
	for(i = 0;i<=m;i++)
		for(l = 1;l<=m;l++)
		{
			j = i+l;
			for( k=0;k<l;k++)
			{
				q = c[i][k]+c[k+1][j];
				if(q>c[i][j])
					c[i][j] = q;
			}
		}
	}
	return c[0][m]
运行时间为 O(m^3）

16.1-2 假定我们不再一直选择最早结束的活动，而是选择最晚开始的活动，前提仍然是与之前选出的所有活动均兼容。描述如何利用这一方法设计贪心算法，并证明算法会产生最优解。
假设选择最晚开始的活动aj不是最优解，即存在活动am包含于[s[aj],f[n]]中，此时s[am]>s[aj]，违反条件aj最晚开始，因此最晚开始的活动也会产生最优解。
最早结束和最晚开始思路完全相同，伪代码如下：
SELECTOR(s,f)
{
	s = sort(s)
	f = sort(f);//按活动开始时间排序
	n = s.length;
	A = {an};
	k = n;
	for(m = n-1;m>=1;m--)
	{
		if(f[m]<=s[k])
			A = A∪{am};
			k = m;
	}
	return A;
}

16.1-3 对于活动选择问题，并不是所有贪心方法都能得到最大兼容活动子集。请举例说明，在剩余兼容活动中选择持续时间最短者不能得到最大集。类似的，说明在剩余兼容活动中选择与其他剩余活动重叠最小者，依据选择最早开始者均不能得到最优解。
若按持续时间最短来选取活动，则其结果为：{a2,a4,a11},若按活动重叠最小选取活动，其结果为{a11,a1,a4,a8},若按最早开始者，其结果为{a3,a7,a11}。
从结果来看，只有重叠活动最小的具备最优解结果，但其是否始终能够得到最优解，可在其他情况中被推翻，此处省略。

16.1-4 假定有一组活动，我们需要将它们安排到一些教室，任意活动都可以在任意教室进行，我们希望使用最少的教室完成所有活动，设计一个高效的贪心算法求每个活动应该在哪个教室进行。（这个问题称为区间着色问题，我们可以构造一个区间图，顶点表示给定的活动，边连接不兼容的活动，要求用最少的颜色对顶点进行着色，使得所有相邻顶点的颜色均不相同）
GREEDY-ACTIVITY(A,B)
{
 	B = sort(B);//将颜色按照优先级从大到小排序。
	n = A.length;//顶点数目
	array C[B.length];储存要使用的颜色
	for(i =1;i<= n;i++)
	{
 		j=A[i].around;//获取A[i]周围直接相连的颜色集合	
		A[i].col = [B∪~j].first;
		if(A[i].col∩C = nil])
		C.pushback(A[i].col)
	}
	return C;
}

16.1-5 考虑活动选择的一个变形：每个活动ai除了开始和结束时间外，还有一个值vi，目标不再是求规模最大的兼容活动子集，而是求值之和最大的兼容活动子集。也就是说，选择一个兼容活动子集A，使得∑vk最大化，设计一个多项式时间的算法求解此问题。
动态规划必然可以解决本问题，并且是多项式时间的算法。问题在于是否存在贪心算法能够解决本问题？
兼容活动子集的值之和最大，其依赖于活动子集数目和每个活动子集的值，在初始情况下找不到最合适的选择，因此不存在贪心算法解决本问题，转而利用动态规划



















