15.1（有向无环图中的最长简单路径）给定一个有向无环图G=（V,E），边权重为实数，给定图中两个顶点s和t。设计动态规划算法，求从s到t的最长加权简单路径。子问题图是怎样的？算法的效率如何？
直接进行循环递归的方法如下：
MAX-PATH(C,s,t) //数组C保存所有边的权值
{
	array E[n];//保存s到每个点的最长距离，E是个map
	for(i=1;i<=n-1;i++);
		E[i] = -∞；
	E[0] = 0;//保存E[s] = 0;
	adjust(s);
	return E[t];
}

adjust(x)
{
	if(x.next != nil);
	{	
		for(i=1;i<=x.next.length;i++)
		{	
			E[x.next] = max(E[x]+C[x][x.next[i]],E[x.next]);
			adjust(x.next[i]);
		}
	}
}

如果要以动态规划的方法解决问题，必须将该有向无环图组织成树的形式，以防止子问题的重复计算。（具体思路见Some_thoughts.doc）
MAX-PATH(E,C,s,t)//数组E包含树的每层所有元素
{
	array B[n][n] = -∞;//保存从s到从b[i][j]的最长路径长度
	for(j=1;j<=C[s.row+1].length;j++)
	{
		B[s.row+1][j] = LONGEST(s,C[s.row+1][j]);
	}	
	for(l=s.row+1;l<t.row-1;l++)
	{
		for(i=1;i<=C[l+1].length;i++)
			for(j=1;j<=C[l].length;j++)
			{
				q = LONGEST(C[l][j],C[l+1][i])+B[l][j];
				if(q>B[l+1][i])
					B[l+1][i] = q;
			}
	}
	for(j=1;j<=C[t.row-1].length;j++)
	{
		q = LONGEST(C[t.row-1][j],t)+B[t.row-1][j];
		if(q>B[t.row][j])
			B[t.row][t.col] = q;
	}
	return B;
}
longest(a,b)//返回相邻两层之内的结点a到b最大距离。E保存所有边的权值。可用类似于adjust的函数求值。

15-2 （最长回文子序列） 回文是正序和逆序相同的非空字符串。设计高效算法，求给定输入字符串的最长回文子序列。例如，给定character，应返回carac。算法的运行时间如何？
本题与求最长公共子序列问题类似，具有相同的子问题结构，共有n(n+1)/2个子问题。
用数组c[i][j]来保存从i到j的最大回文序列长度。
用数组d[i][j]来保存最大回文序列的位置（x,y）。
伪代码如下：
MAX-PALINDROME(A，n)
{
	array c[n][n],d[n][n];
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
			if(i==j)
				c[i][j] =1;
			else c[i][j] = -∞;
   	for(l=2;l<=n;l++)
	{
		for(i=1,i<=n-l+1;i++)
		{
			q = 0,p = 0;
			j = i+l-1;
			for(k = d[i+1][j].y+1;k<=j;k++)
				if(A[i]==A[k])
					c[i][j] == c[i+1][j]+1;
					d[i][j] == (i,k);
			for(m = d[i][j-1].x-1;m>=i;m--)
				if(A[j]==A[m])
					c[i][j] == c[i][j-1]+1;
					d[i][j] == (k,j);
		}
	}
	return c,d;
}
15-3 （双调欧几里得旅行商问题） 设计一个O(n^2)时间的最优双调巡游路线算法。
给定n个点，按其x坐标从小到大排序得到集合A[n]。按照双调巡游性质，可将A[1]到A[n]之间的n-2个点划分为2个集合，一个集合代表向右巡游集合，另一个代表向左巡游集合，因此存在路线数目为2^(n-2)个（两条路线可对称交换，因此，实际唯一路线有2^（n-3）个）。
最优子结构：对于A[i,j]，其最优双调巡游路线为optimal_line(i,j) = right(i,j)+left(i,j),当增加一个点j+1时，需要判断right和left路线曾经的公共节点A[j]在最优情况下属于哪个集合，以维持A[i,j+1]的最优结构。
伪代码如下：
OPTIMAL_LINE(A,n)
{
	A[n] = sort(A[n].x);
	list left[n],right[n]; //定义两个链表链接两个集合的元素，left指向left[n]最后一个元素，right指向right[n]最后一个元素。
	array d[n],d_left[n],d_right[n]// 保存最优长度
	left[1] = A[1];
	left[2] = A[2];
	d_left[1] = 0,d_left[2] = dist(A[1],A[2]); 
	right[1] = A[1];
	right[2] = A[2];
	d_right[1] = 0,d_right[2] = dist(A[1],A[2]);	
	for(i = 3;i<=n;i++) // 至少3个点才能形成双调巡游
	{
		q1 = d_left[i-2]+dist(left.pre,A[i])+d_right[i-1]+dist(right,A[i]);//点i分配给right集合
		q2 = d_right[i-2]+dist(right.pre,A[i])+d_left[i-1]+dist(left,A[i]);//点i分配给left集合
		if(q1<=q2)
			d_left[i] = d_left[i-2]+dist(left.pre,A[i]);
			d_right[i] = d_right[i-1]+dist(right,A[i]);
			left.pre.next = A[i],left = A[i];
			temp = right,right = A[i],right.pre = temp,temp.next = A[i];
		else 与上相反。
	}
}

暂时不理解为什么最优解为O(n^2)可能是最优子结构的划分出现问题，查了网上的答案，还是不能让人信服。

15-4 （整齐打印）考虑整齐打印问题，即在打印机上用等宽字符打印一段文本。输入文本为n个单词的序列，单词长度分别为L1，L2,...Ln个字符。我们希望将此段文本整齐打印在若干行上，每行最多M个字符。“整齐”的标准是这样的：如果某行包含第i到第j（i<=j）个单词，且单词间隔为一个空格符，则行尾的额外空格符数量为M-j+i-∑Lk(k = i:j）,此值必须为非负的，否则一行无法容纳这些单词。我们希望能最小化所有行的（除最后一行外）额外空格数的立方之和。设计一个动态规划算法，在打印机上整齐打印一段n个单词的文本。分析算法的时间和空间复杂性。
ALIGNED_PRINT(A,n,M)
{
	array w[n][n];//w[i][j]表示从i到j的单词放在一行时额外空格数的立方
	array c[n];//c[i]表示前i个字符的立方和;
	array K[n]; 储存对于每个i值，其对应的末行首元素
	c[0] = 0;
	for（i=1;i<=n;i++）
		for(j=i;j<=n;j++)
		{
			w[i][j]= +∞;
		}	
	for（i=1;i<=n;i++）
		for(j=i;j<=n;j++)
		{
			a = EXTRAL-SPACE(i,j,M);
			if(a<0)
				break;
			else w[i][j]= a*a*a;
		}
	for(i=1;i<=n;i++)
	{
		c[i] = +∞
		for(k = i;k>=1;k--) //内层循环逆序求解
		{
			if(w[k][i] == +∞)
				break;
			q = c[i-k+1]+w[k][i];
			if(q < c[i])
			{
				c[i] = q;
				K[i] = k;
			}
		}
	}
}

本题参考了网上的答案，按理来说应该是一道很常规的动态规划题，直接暴力动态规划即可解决，深思做不出来的原因如下：
A.面对问题时，总是尝试以人脑穷尽所有可能的方案！而本体中，子问题分类错综复杂，每一行容纳的元素个数受题设条件、单词长度、上下行长度等影响，想要以人脑穷极各种边界条件，简直是在做梦。
B.受定性思维影响，认为给定n个元素后，可直接求解出其打印出的总行数，只需要对每行进行微调，就可获得最优解。该思路完全偏离动态规划的思想，脱离了将大问题分解成依赖性的子问题的思路，直觉给出的解题方向并不能保证在所有情况下可靠，因此越想到后面，思路越混乱。




























