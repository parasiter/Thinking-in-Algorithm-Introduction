15.1-1 由公式（15.3）和初始条件T（0）=1，证明公式15.4成立。
公式15.3：T（n）= 1 +∑T（j）//初始j = 0 ，最后j = n-1;
当n = 1 时，T（n） = 1 + T（0） = 2 ,成立。
T(n) = 1+ T（n-1）+ ∑T（j）//初始j = 0 ，至j = n-2;
T(n) = T(n-1)+[1+∑T（j）] = 2 T(n-1);
求解上式得T（n） = 2^n;

15.1-2 举反例证明下面的“贪心”策略不能保证总是得到最优切割方案。定义长度为i的钢条的密度为Pi/i，即每英寸的价值。贪心策略将长度为n的钢条切割下长度为i的一段，其密度最高，接下来继续使用相同的策略切割钢条长度为n-i的剩余部分。
当钢条长度为4时，如果按照“贪心策略”，其切割方式应为3+1，此时收益为9，并非最优切割方案2+2，收益为10。因此，“贪心”策略不能保证总是得到最优切割方案。

15.1-3 我们对钢条切割问题进行一点修改，除了切割下的钢条段具有不同的价格Pi外，每次切割还要付出固定的成本c。这样，切割方案的收益就等于钢条段的价格之和减去切割的成本。设计一个动态规划算法解决修改后的钢条切割问题
伪代码如下：
EXTENDED-BOTTOM-UP-CUT-ROD(P,N)
{
	array r[n],s[n];//r[n]保存所有规模问题的最优解，s[n]保存所有规模的最佳切割位置。
	r[0] = 0;
	for(i=1;i <= n; i++)
	{
		q = -∞；
		for（j = 1;j <= i ; j++）
		{
			sum = P[j] + r[i-j];
			if(i == j)
				sum = sum + c;
			if(q < sum)
			{
				q = sum;			   	
				s[i] = j;
				r[i] = q-c;
			}
		}
	return r[n],s[n];
}

15.1-4 修改MEMORIZED-CUT-ROD,使之不仅返回最优收益值，还返回切割方案。
返回当问题规模为n时，保存其最佳切割位置为s[n],这很容易实现，故因此略过，下述伪代码利用s[n]数组来返回最佳切割方案：
PREFER-CUT-SITE(s,n)
{
	if[s[n]=n]
		return n;
	else 
	{	
		print s[n];
		PREFER-CUT-SITE(s,s[n]);	
		PREFER-CUT-SITE(s,n-s[n]);
	}
}

15.1-5 斐波那契数列可以用递归式（3.22）定义，设计一个O(n)时间的动态规划算法计算第n个斐波那契数。画出子问题图。图中有多少个顶点和边。
对于斐波那契数列，T(n) = T(n-1)+T(n-2)，可以此画出子问题图，此处省略。图中存在n个顶点，2n-3条边。
FIBONACCI-ARRAY(n)
{
	array T[n];
	T[1] = 0;
	T[2] = 1;
	for(i = 3;i<=n;i++)
	{
		T[i] = T[i-1]+T[i-2];
	}
	return T[n];
}

	

















