18.2-1 画出连续插入序列<F,S,Q,K,C,L,H,T,V,W,M,R,N,P,A,B,X,Y,D,Z,E>的空B树结构。
纸上已画，略。

18.2-2 请解释什么情况下（如果有的话），在调用B-TREE-INSERT的过程中，会执行冗余的DISK-READ，或DISK-WRITE操作。
调用B-TREE-INSERT过程中，会在B-TREE-SPLIT-CHILD发生写操作，在B-TREE-INSERT-NONFULL最终插入叶结点时发生写操作，在从根下行时发生读操作。
因为DISK-READ操作只发生在沿根单程下行过程中，如果发生冗余操作，只可能因为根高度+1，因此只有在根结点是满的时候，读取根结点，分裂，高度+1，在新根结点处再次读入原根分裂的两个结点，仅在此处发生DISK-READ操作冗余。
同样的，因为发生DISK-WRITE操作时，一定存在结点被修改，或者分裂，或者插入，因此不会发生DISK-WRITE操作。

18.2-3 请说明如何在一棵B树中找到最小关键字，以及如何找出某一关键字的前驱。
FIND-MIN（T）
{
	x = T.root
	while(!x.leaf)
	{
		x = x.c1
	}
	return x;		
}
FIND-PROCESSOR(T,k)
{
	x = T.root;
	i = 1;
	y = nil;
	while(!x.leaf)
	{
		while(i<=x.n+1&&k>x.keyi)
			i=i+1;
		y = x.key(i-1)	
		x = x.ci;	
	}
	for(i=1;i<=x.n;i++)
		if(x.keyi==k&&i>1)
			return x.key(i-1);
		else return y;
}	

18.2-4 假设关键字{1,2,3...n}被插入一棵最小度数为2的空B树中，那么最终的B树有多少个结点?
按顺序插入，会导致最多只有最后一个结点向根上行路线可能存在满结点状态，其他结点关键字数目均保持下界。
当所有结点关键字数目均在下界时，形成完全二叉树，结点数 = n，树高为lgn，最后一条简单路径上可最多容纳2lgn的关键字，
因此对于关键字在n~n+2lgn范围内形成的B树，最终的B树会有n个结点。

18.2-5 因为叶结点无需指向孩子结点的指针，那么对同样大小的磁盘页面，可选用一个与内部结点不同的（更大的）t值。请说明如何修改B树的创建和插入过程来处理这个变化
如果储存指针的空间和储存关键字的空间一样大，可以对叶结点设置t = 2t+1。

18.2-6 假设B-TREE-SEARCH的实现是在每个结点内采用二分查找，而不是线性查找。证明：无论怎样选择t（t为n的函数），这种实现所需的CPU时间都为O（lgn）
存在t-1<= n <= 2t-1，因此CPU时间为O（lgn）

18.2-7假设磁盘硬件允许我们任意选择磁盘页面的大小，但读取磁盘页面的时间是a+bt,其中a和b为规定的常数，t为确定磁盘页大小后的B的最小度数。请描述如何选择t以最小化B树的查找时间，对a=5ms和b=10ms,请给出一个t的最优值。
B树的目的就是为了平衡每个结点内部的检索时间（内存）和不同结点间的检索时间（磁盘）。
T = logt（n）*(a+bt) + logt(n)*log2(t)
求最优值略。。。。































