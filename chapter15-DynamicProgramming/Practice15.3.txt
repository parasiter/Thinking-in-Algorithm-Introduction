15.3-1 对于矩阵链乘法问题，下面两种确定最优代价的方法哪种更高效？第一种方法是穷举所有可能的括号化方案，对于每种方案计算乘法运算次数，第二种是运行RECURSIVE-MATRIX-CHAIN，证明你的结论。
明显第二种，第一种相当于递归求解，第二种才是动态规划算法。

15.3-2 对一个16个元素的数组，画出2.3.1节中MERGE-SORT过程运行的递归调用树。解释备忘技术为什么对MERGE-SORT这种分治算法无效。
画递归调用树省略。
无效的原因在于，MERGE-SORT不具备重叠子问题性质，其每一个子问题只使用一次，且必须求解。

15.3-3 考虑矩阵链乘法问题的一个变形：目标改为最大化矩阵序列括号化方案的标量乘法运算，而非最小化。此问题具备最优子结构性质吗？
具备最优子结构性质，因为括号化不管是求最大化还是最小化乘法运算次数，其子问题之间都是无关的。

15.3-4 如前所述，使用动态规划方法，我们首先求解子问题，然后选择哪些子问题用来构造原问题的最优解。Capulet教授认为，我们不必为了求原问题的最优解而总是求解出所有子问题，她建议，在求矩阵链乘法问题的最优解时，我们总是可以在求解子问题之前选定AiAi+1...Aj的划分位置Ak（选定的k使得P(i-1)PkPj最小）。请找出一个反例，证明这个贪心算法可能生成次优解。
最优解必定满足一个k的递增比较过程，如果从一开始就给定k值，也即是选定了划分点，它的每一次给定划分，均只有1/（j-i）的最优解概率，其次均为次优解。

15.3-5 对15.1节的钢条切割问题加入限制条件：假定对于每种钢条长度i（i=1,2,...,n-1）,最多允许切割出Li段长度为i的钢条。证明：15.1节中所描述的最优子结构性质不再成立。
破坏了两个平行子问题间的无关性。即当已经做出Li次i长切割后，后面的子问题完成最优解需要继续i长切割时，不被允许。

15.3-6 问题太长....
伪代码如下：
EXCHANGE(r,1,n,c)
{
	array p[N][N], c[N][N];//保存最优解和最优切割位置
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
			p[i][j] =r[i][j];
			c[i][j]	= -∞;
	for(l=3;l<=n;l++)
	{
		for（i=1;i<=n-l+1;i++)
		{
			j = i+l-1;
			for(k=1;k<=l-1;k++)
			{
				q = p[i][k]*p[k+1][j]-c;
				if(q>p[i][j])
				{
					p[i][j] = q;
					c[i][j]	= k;
				}
			}
		}		
	}
当c = 0时，显然类似于矩阵链，符合最优子结构性质。
当c 取任意值时，必定存在一个值Ck,使得当取值超过k次时，收益变为负值，因此本题实质转换成上题（15.3-5）,因此，不一定具备最优解。