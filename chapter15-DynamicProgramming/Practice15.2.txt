15.2-1 对矩阵规模序列<5,10,3,12,5，,50,6>，求矩阵链的最优括号方案。
略

15.2-2 设计递归算法MATRIX-CHAIN-MULTIPLY(A,s,i,j),实现矩阵链最优代价乘法计算的真正计算过程，其输入参数为矩阵序列<A1,A2,...An>,MATRIX-CHAIN-ORDER得到的表s，以及下标i和j。（初始调用应为MATRIX-CHAIN-MULTIPLY(A，s,1,n）。)
MATRIX-CHAIN-MULTIPLY(A，s，1，n)
{
	for(j =2;j<=n;j++)
	{
		for(i =1;i<=n-j+1;i++)
			s[i,j] = ∞;
	}
	return MEMORIZED-MATRIX-CHAIN(A,s,1,n);
}
MEMORIZED-MATRIX-CHAIN(A,s,i,j)
{
	array c[N,N]; //保存切割位点
	if(j ==1)
		return 0;
	if(s[i,j]<∞)
		return s[i,j] //如果用到相同子问题，返回该值。
	for(k=1;k<j;k++)
	{
		q=MEMORIZED-MATRIX-CHAIN(A,s,i,k)+MEMORIZED-MATRIX-CHAIN(A,s,i+k,j-k)+Pi-1*Pk*Pi+j;
		if(q<s[i,j])
		{
			s[i,j] = q;//保存最小值
			c[i,j] = k;
		}	
	}
	return s[i,j] c[i,j];
}

15.2-3 用带入法证明递归公式（15.6）的结果为Ω（2^n）。
当n = 2时，p（2）=1;
当n = 3时，p（3）=2;
假设p（n）/p(n-1)>=2,则：
p(n) = p（1）*p(n-1)+p(2)*p(n-2)+p(3)*p(n-3)...+p(n-1)*p(1)
     >= p（1）*p(n-2)*2+1*p(1)*p(n-2)+2*p(2)*p(n-3)...+2*p(n-2)*p(1)
     >= 2*[p（1）*p(n-2)++2*p(2)*p(n-3)...+2*p(n-2)*p(1)]+p(1)*p(n-2)
     >= 2*p(n-1)+p(1)*p(n-2) >2*p(n-1)
证明成立，则带入递归式可得p（n）=Ω（2^n）。

15.2-4 对于链长度为n的矩阵链乘法问题，描述其子问题图：它包含多少个顶点？包含多少条边？这些边分别连接哪些顶点。
对于链长为n的矩阵链乘法，包含n个顶点，且其解决方案有P（n)个，且依据递归公式（15.6），可知P（1） = 1，P（2） = 1，满足卡塔兰数列的条件。

15.2-5 令R（i,j）表示在一次调用中,MATRIX-CHAIN-ORDER过程中，计算其他表项访问表项m[i,j]的次数。证明∑∑R（i,j） = (n^3-n)/3
即计算R[1,n]时，访问表项m[i,j]的总次数。
首先，需要对表项进行构建，构建方法为计算所有子问题的最优解，从子问题规模为l=2 to n构建，
当l = 2 时，对于长度为n的矩阵链，共有n-l+1个子问题，其中每个子问题会调用P(2)个m[i,i]表项，其中P（2）= 2*（l-1）
当l = n-1 时，对于长度为n的矩阵链，共有n-l+1=2个子问题，其中每个子问题会调用P(n-1)个m[i,i+l-2]表项，其中其中P（n-1）= 2*（l-1）=2*（n-2）//P(n-1)即为递归式（15.6）的k取值个数。
因此一共调取表项次数M（n）=∑(n-l+1)(l-1)*2//for l = 2:n;
求和得M（n）= 2(n^3-n)/3    //与题目结果有差异，多出了一个系数2。

15.2-6 证明：对n个元素的表达式进行完全括号化，恰好需要n-1对括号。
对n个元素的矩阵链，随机选取一对进行括号化，括号数+1，矩阵数-1，进行循环，最好恰好需要n-1对括号。






























