19-1（删除操作的另一种实现）题目长，略。
a.该教授的声称是基于第7行可以在O（1）实际时间内完成的这一假设，它的程序可以运行的更快。该假设有什么问题吗？
有问题，虽然子结点都是链表结构，插入到根链表时，只需更改O（1）个指针，操作代价为O（1），但是，每个子结点的x.p均要进行修改，因此操作代价为O（x.degree），总操作代价为O（x.degree）

b.当x不是由H.min指向时，给出PISANO-DELETE实际时间的一个好上界。你给出的上界应该用x.degree和调用CASCADING-CUT的次数c这两个参数来表示。
整个过程为将x.child全部插入到根结点，级联删除x结点。总代价为O（degree+2c)

c. 假定调用PISANO-DELETE(H,x),并设H'是执行后得到的斐波那契堆。假定结点x不是一个根，用x.degree、c、t(H)来表示H'势的界。
Φ（H'） = t(H')+2m(H')
每进行一次删除，Φ（H'）=[t(H')+x.degree+c]+2[m(H')-c+2]=t(H')+2m(H')+x.degree-c+4 = O(n)（所有结点都成为了根结点）

d. 证明：PISANO-DELETE的摊还时间渐进的不好于FIB-HEAP-DELETE的摊还时间，即使x≠H.min时也是如此。
从直觉上来看，PISANO-DELETE操作将FIB-HEAP-DELETE操作中的EXTRACT-MIN直接更改为了将x.child并入根结点，这样虽然避免了合并时间，但这样会导致根节点数目趋近与n，从而导致后续的合并操作代价更高，失去性能平衡。

19-2 （二项树和二项堆）题目长，略
a. 对于二项树Bk，证明：
1. 一共有2^k个结点。 2. 树的高度是k。 3. 对于i=0,1,...k，深度为i的结点恰有Cik（组合）个。 
4. 根的度数为k，它比其他任意结点的度数都要大。此外，如图19-6（c）所示，如果把根的孩子从左到右编号为k-1，k-2...0，那么孩子i是树Bi的根。
1.Bk = 2Bk-1,B0=1,因此，Bk =2^k。
2.对于高度H（k） = H(k-1)+1,因此，H（k）= k。
3.用归纳法证明：
当i = 0 时，等式成立
当i = j 时，N1 = Cjk= Cj(k-1)+c(j-1)(k-1)  是两棵树高为k-1树深度为i和i-1的组合，等式成立。
4.树Bk其子结点为B0，B1.Bi..Bk-1，因此对于任意子结点，其度数为i，i∈[0,k-1]。

b.(二项堆)性质有1.每个结点具有一个关键字 2.H中每个二项树遵循最小堆性质 3.对于任意非负整数k，H中最多有一个二项树的根的度数为k。
假定一个二项堆H一共有n个结点。讨论H中包含的二项树与n的二进制表示之间的关系。并证明H最多由sub(lgn)+1棵二项树组成。
显然，依据性质，二叉堆的树可以用n的二进制表示，位i表示是否存在该树，该树的结点数为2^(i-1)。因此每插入一个结点，必然存在一个二进制来表示二叉堆的情况。sub(lgn)+1可以表示n的二进制位数，也可以表示树的最大数目。

c. 完整描述如何表示一个二项堆（例如，对属性进行命名，描述属性值什么时候为NIL，定义根链表是如何组织的），并说明每一个操作的最坏时间应该为O（lgn），其中n为二项堆中的结点数目（或对于UNION操作，为何要被合并的两个二项堆中的结点数）。MAKE-HEAP操作应为常数时间。
每个结点储存3个指针：x.p, x.child, x.brother。两个值:x.key, x.degree。
MAKE-HEAP():创造和返回一个新的不含任何元素的堆。摊还时间O（1）。
INSERT(H,x):将一个已填入关键字的元素x插入堆H的根链表中，然后进行合并。其摊还代价与二进制计数器摊还代价相同，为O（1）。
MINIMUM(H):遍历根链表，找出最小元素，最多存在O（lgn）个根结点，因此操作代价最坏为O（lgn）
EXTRACT-MIN(H):找到最小元素，代价O（lgn）,将所有k（lgn）个子结点放入根链表，遍历根链表，进行合并，花费时间为O（lgn）
UNION(H1,H2):合并两个二项堆，连接根链表，维护属性3，需要遍历整个根链表，代价为O（max(lgn1,lgn2))
DECREASE-KEY(H,x,k):直接维护本二项树即可，因为树高最高为lgn。
DELETE(H,x):与上相同，代价lgn。

d.假定仅仅要实现在一个斐波那契堆上的可合并操作（即并不实现DRECRESE-KEY和DELETE操作）。斐波那契堆中的树与二项堆中的树有何相似之处？有什么区别？证明在一个n个结点的斐波那契堆中的最大度数最多为lgn。
斐波那契堆中的树，希望一切操作都在根结点上解决，因为根结点的数目上限为O（lgn）,因此各种操作的代价都基于此，为O(lgn)。而二项堆中的树不但根结点数目上限为O(lgn),且其树高为为k，n = 2^k，因此k = lgn。因此二项堆的树高也为lgn。
斐波那契堆的最大度数为k-1,且k = lgn，因此最大度数最多为lgn。

e.McGee教授提出了一个基于斐波那契堆的新的数据结构。一个McGee堆具有与斐波那契相同的结构，并且只支持可合并堆操作。除了插入和合并在最后一步中合并根链表外，其他操作的实现方式均与斐波那契堆中的实现方式相同。McGee对上各操作的最坏情况运行时间是多少？
如果在插入操作后要进行合并根链表，那么插入操作的代价为O（lgn）。
如果在合并操作后要进行合并根链表，那么合并堆操作的代价为O（lgn1+lgn2)）
其他操作代价相同

19-3（更多的斐波那契堆操作）想要拓展斐波那契堆H支持两个新操作，要求不改变斐波那契堆其他操作的摊还时间。
a.操作FIB-HEAP-CHANGE-KEY(H,x,k)将结点x中的关键字的值改为k。给出FIB-HEAP-CHANGE-KEY的一个有效实现，并分析k大于、小于或等于x.key时，各情形下的摊还时间。
