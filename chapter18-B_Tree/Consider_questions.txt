18-1（辅存上的栈）题目长，略
a. 从渐进意义上看，使用这种简单实现，在最坏的情况下，n个栈操作需要多少次磁盘存取？CPU时间又是多少？
在这种简单实现中，每次push操作都会进行读取磁盘操作一次，写入磁盘操作一次；每个pop操作都会读取磁盘操作一次；
因此最坏情况下，n个操作最多需要2n次磁盘存取，θ（nm）次CPU时间。

b.最坏情况下，n个PUSH操作所需的磁盘存取次数是多少？所需的CPU时间是多少？
最坏情况下，连续的n个push操作会导致n/m（向上取整）次主存页切换，2n/m次磁盘存取，CPU时间为θ（n）

c. 最坏情况下，n个栈作所需的磁盘存取次数是多少？所需的CPU时间是多少？
最坏情况下，主存中保存的页会不断切换，即栈顶指针（p mod m）=0时发生POP操作，(p mod m)=m-1时发生PUSH操作。
此时，每次连续的POP和PUSH会导致一次磁盘读取和一次磁盘写入。因此n个栈操作会导致n次磁盘存取，CPU时间为θ（nm）

d. 请描述如何管理栈页，使得在任何栈操作的摊还磁盘存取次数为O（1/m），摊还CPU时间为O（1）。
使主存中保存两个栈的页，使得：
当PUSH操作导致（p mod m）=3/4m时，舍弃p/m-1页，加载p/m+1页。
当POP操作导致（p mod m）=1/4m时，舍弃p/m+1页，加载p/m-1页。
这样会保证最坏情况下，经历(1/2)m次操作才会发生一次磁盘存取，栈操作的摊还存取次数为O（1/m）,摊还CPU时间为O(1)

18-2（连接和分裂2-3-4树）题目长，略
a. 对2-3-4树中的每个结点x，说明如何将以x为根的子树的高度作为一个属性x.height来维护。要确保所给出的实现不影响查找、插入和删除的渐进运行时间。
在插入操作中，只有根结点含有2t-1个关键字时，树高+1；同样的，在删除操作中，只有当根结点只有一个，且其子结点关键字个数都为t-1时，树高-1。
因此，可只维护一个总的树高，当需要查找某个结点时，沿根下行，计算该结点高度即可。

b. 说明如何实现链接操作。给定两棵2-3-4树，T'和T''和一个关键字k，连接操作应该在O（1+|h'-h''|）运行时间内完成，其中h'和h''分别是树T'和T''的高度。
假设h'<h''，则可以将T'的根节点作为一个结点并入到T''的高度为h''-h'处的最小结点，中间以关键字x相连，如果该结点的关键字大于4，则开始从T''根节点至该合并结点的简单路径进行B树性质维护。因此连接操作运行时间为O（1+|h'-h''|）。

c.考虑从一棵2-3-4树T的根到一个给定关键字k的简单路径p,T中小于k的关键字集合S',以及T中大于k的关键字集合S''。证明：p将S’分为一个树的集合{T1'...TM'}和一个关键字的集合{k1'...km'}，且对于任何关键字y∈T(i-1)'和z∈Ti'(i=1,2,...m)，都有y<ki'<z。T(i-1）'和Ti'的高度之间有什么关系？请说明p是如何将S''分为树集合和关键字集合的。
h（i-1）' = hi'+1(关键字越大，树高越低)。p从叶结点延伸至根结点，每次上行，都会得到一个指针指向本结点，以此为分割点，会形成一棵树Ti'，和一个关键字ki'（因为失去了一个指向子结点的指针，必须分裂出一个关键字出来，维护剩下的结点形成一棵有效的树），继续上行，重复该过程，每次分裂形成一棵树和一个关键字。

d. 请说明如何实现T上的分裂操作。利用连接操作将S'中的关键字拼成一棵简单的2-3-4树T’，将S''中的关键字拼成一棵简单的2-3-4树T''，分裂操作的运行时间要求为O（lgn），这里n是T中的关键字个数。
分裂操作与插入操作十分类似，此处略。

