17.2-1 假定对一个规模永远不会超过k的栈执行一个栈操作序列，执行k个操作后，我们复制整个栈来进行备份。通过为不同的栈操作赋予适合的摊还代价，证明：n个栈操作的代价为O（n）。
将操作赋予如下摊还代价：
PUSH      2
POP       0
MULTIPOP  0
COPY      0
每次运行PUSH时花费1的操作代价，将额外1的代价储存在本元素x中，这个代价会在删除本元素时，或者复制本元素时被消耗。因此在任意时刻，总信用始终为非负值。

17.2-2 用核算法重做练习17.1-3
将每个操作的摊还代价均定为3,那么当进行第n个操作时，总信用为：
T = 3n - [n- sub(lgn)(向下取整)+（1+2+...2^sub(lgn)）] = W(sub(lgn))>=0
因此，在任意时刻，总信用均为非负值。因此每个操作的摊还代价为O（1）。

17.2-3 假定我们不仅对计数器进行增1操作，还会进行置0操作。设检测或修改一个为的时间为Θ（1），说明如何用一个位数组来实现计数器，使得对于一个初始值为0的计数器执行一个由任意n个INCREMENT和RESET操作组成的序列花费时间为O（n）。
对位数组添加一个指针，指向最高位的1。
并赋予每次置位的摊还代价为3。
由之前的章节已知，当n->+∞时，总置位次数为n。
同样的，每置位一次，消耗1代价，每进行复位一次时，会消耗留下的一个信用，但是对于未复位的位置，依然会遗留下一个信用，这个信用会在RESET操作复位时被使用，当进行RESET操作时，会遍历所有最高位以下的位数，会使用固定的每位1个代价。
因此，当摊还代价为3时，即可使在任意时刻总信用为非负。