17-1（位逆序的二进制计数器） 题目长，略
a. 设计一个运行时间为Θ（k）的函数REVk，编写算法在O（nk）时间内对长度为n = 2^k的数组执行位逆序置换。
REV(k)
{
	for(i=1;i<=k/2;i++)
	{
		swap(i,k-i+1)
	}
}
REVERSE-REPLACEMENT(A，n,k)
{
	for(i=1;i<=n;i++)
	{
		b = REV（k）
		if(i< b)
		{
			swap(A[i],A[B])
		}
	}
}

b. 假定你的计算机每个机器字保存k位二进制数，而一个机器字中的值进行一次任意偏移量的左/右移位、位与、位或等操作只需单位时间。设计一个BIT-REVERSED-INCREMENT过程，能使一个n个元素的数组上的位逆序置换操作在O（n）时间内完成。
依据题意，BIT-REVERSED-INCREMENT过程，能使一个n个元素的数组上的位逆序置换操作在O（n）时间内完成，则说明数组中的每个元素的摊还代价为O（1）。
考虑到BIT-REVERSED-INCREMENT实际上就是一个逆向的二进制加法问题，本质上就是一个逆序的二进制加法器，因此，其摊还代价与17.2章的二进制计数器递增的摊还代价相同，伪代码如下：
BIT-REVERSED-INCREMENT(A，k)
{
	for(i=k;i<=1;i--)
	{
		A[i]= 0 ;
	}
	print A;//打印首元素
        //开始进行逆序加法
	n = 2^k;
	for(i=1;i<n;i++)
	{
		j = k;
		while(A[j]==1)
		{
			A[j]=0;
			j--;
		}
		A[j]=1;
		print A;//每次循环读取出二进制数组A，计算机内的一个字读取操作为逻辑电路获取，不需要计算，时间为O（1）
	}
}
得到所有二进制逆序下标后，置换所有原下标小于二进制逆序下标的元素即可。
依据17.2节的二进制计数器每次递增的分析可知，每次递增的摊还代价为O(1)，同样本题中遍历n个元素的数组，得到其逆序下标的摊还代价为O（1），因此得到所有元素的逆序下标只需O（n）的时间即可完成。

c. 假定在单位时间内你只能完成左/右移一位的操作。还可能实现O（n）时间的位逆序置换操作吗？

17-2（动态二分查找） 有序数组的二分查找花费对数时间，但插入一个新元素的时间与数组的规模呈线性关系。我们可以通过维护多个有序数组来提高插入性能。（剩余文字略）
a. 设计算法，实现这种数据结构上的SEARCH操作，分析其最坏情况运行时间。
SEARCH(n,a)
{
	k = sup(lg(n+1));//sup（）取上限
	for(i=0;i<k;i++)
	{
		if(a>=Ai.min&&a<=Ai.max)
			if(BINARY-SEARCH(Ai,a));//在数组Ai中查找元素a;
				return Ai;
	}
	return "not found"
}
最坏情况下，对于每个数组，均为非空，都要遍历,因此总时间为∑lgAi = ∑i = (k-1)k/2 = Θ(k^2) 

b. 设计INSERT算法。分析最坏情况运行时间和摊还时间
INSERT(n,a)
{
	B[q] = getbinary(n);
	B'[p] = getbinary(n+1);
	m = 0;//保存插入元素后，最后发生进位的位置
	if(p>q)
		m = q;
	else
		for(i=0;i<=q;i++)
		{
			if(B[i]==0&&B'[i]==1)
				m = i;
				break;
		}
	sort(A0+A1+...Am-1) in Am;
}
插入操作在最坏情况下，会导致最高位进位，此时，所有元素都要从原有数组中复制到新数组Ak中，并进行排序。现在分析排序过程的花费时间：
k = lg(n+1)
排序过程如下：
1.初始时，对插入的元素a和A0的元素排序，花费时间1
2.对a+A0，A1元素排序，花费最多MAX(|a+A0|，|A1|)的时间---- 2
3.对a+A0+A1和A2的元素排序，花费最多MAX（|a+A0+A1|,|A2|）--4
以此类推排序花费时间为1+2+2^2+....2^(k-1） = 2^k -1 = n。
最后还要将所有n个元素复制到Ak中，共花费T（n） = n+n+1 = 2n+1 = O(n)
因此最坏情况下插入代价为O（n）。
下面分析插入代价的摊还代价：
由最坏插入代价可知，当插入操作导致<nk-1,...n0>中的i位由0置为1时，其插入代价为2*(2^i-1)+1。(i∈[0,k-1])
而从空集插入到有n个元素时，第i个位置发生置1操作的次数为n/2^(i+1)。因此，第i个位置花费的总操作时间为
T（i）= [2*(2^i-1)+1]*n/2^(i+1)
      = Θ(n)
总代价为T（n） = ∑T（i） = Θ(nk) = Θ(nlgn)
摊还代价为Θ(nlgn)/n = Θ(lgn)	

c.讨论如何实现DELETE
DELETE操作理应来说是INSERT操作的逆操作，但是删除操作不需要对元素进行再排序，只需要进行分配即可。

17-3（摊还加权平衡树）题目长，略
a. 在某种意义上，一棵1/2平衡树达到了极限的平衡。给定任意一棵二叉搜索树中的一个结点x，证明：如何重建以x为根的子树，使得它变为1/2平衡的。你的算法运行时间应该为Θ（x.size），可以使用O（x.size）的辅助空间
先递归打印出所有以x为根的元素到数组中，按从小到大序，此过程花费Θ（x.size）时间，花费O（x.size）的辅助空间。
再递归打印出所有元素，每次选取第n/2的元素作为根节点，此过程花费Θ（x.size）时间。
总共花费Θ（x.size）时间，花费O（x.size）的辅助空间。
























			
		




