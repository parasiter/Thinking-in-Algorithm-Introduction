17-1（位逆序的二进制计数器） 题目长，略
a. 设计一个运行时间为Θ（k）的函数REVk，编写算法在O（nk）时间内对长度为n = 2^k的数组执行位逆序置换。
REV(k)
{
	for(i=1;i<=k/2;i++)
	{
		swap(i,k-i+1)
	}
}
REVERSE-REPLACEMENT(A，n,k)
{
	for(i=1;i<=n;i++)
	{
		b = REV（k）
		if(i< b)
		{
			swap(A[i],A[B])
		}
	}
}

b. 假定你的计算机每个机器字保存k位二进制数，而一个机器字中的值进行一次任意偏移量的左/右移位、位与、位或等操作只需单位时间。设计一个BIT-REVERSED-INCREMENT过程，能使一个n个元素的数组上的位逆序置换操作在O（n）时间内完成。
依据题意，BIT-REVERSED-INCREMENT过程，能使一个n个元素的数组上的位逆序置换操作在O（n）时间内完成，则说明数组中的每个元素的摊还代价为O（1）。
考虑到BIT-REVERSED-INCREMENT实际上就是一个逆向的二进制加法问题，本质上就是一个逆序的二进制加法器，因此，其摊还代价与17.2章的二进制计数器递增的摊还代价相同，伪代码如下：
BIT-REVERSED-INCREMENT(A，k)
{
	for(i=k;i<=1;i--)
	{
		A[i]= 0 ;
	}
	print A;//打印首元素
        //开始进行逆序加法
	n = 2^k;
	for(i=1;i<n;i++)
	{
		j = k;
		while(A[j]==1)
		{
			A[j]=0;
			j--;
		}
		A[j]=1;
		print A;//每次循环读取出二进制数组A，计算机内的一个字读取操作为逻辑电路获取，不需要计算，时间为O（1）
	}
}
得到所有二进制逆序下标后，置换所有原下标小于二进制逆序下标的元素即可。
依据17.2节的二进制计数器每次递增的分析可知，每次递增的摊还代价为O(1)，同样本题中遍历n个元素的数组，得到其逆序下标的摊还代价为O（1），因此得到所有元素的逆序下标只需O（n）的时间即可完成。

c. 假定在单位时间内你只能完成左/右移一位的操作。还可能实现O（n）时间的位逆序置换操作吗？

17-2（动态二分查找） 有序数组的二分查找花费对数时间，但插入一个新元素的时间与数组的规模呈线性关系。我们可以通过维护多个有序数组来提高插入性能。（剩余文字略）
a. 设计算法，实现这种数据结构上的SEARCH操作，分析其最坏情况运行时间。
SEARCH(n,a)
{
	k = sup(lg(n+1));//sup（）取上限
	for(i=0;i<k;i++)
	{
		if(a>=Ai.min&&a<=Ai.max)
			if(BINARY-SEARCH(Ai,a));//在数组Ai中查找元素a;
				return Ai;
	}
	return "not found"
}
最坏情况下，对于每个数组，均为非空，都要遍历,因此总时间为∑lgAi = ∑i = (k-1)k/2 = Θ(k^2) 

b. 设计INSERT算法。分析最坏情况运行时间和摊还时间
INSERT(n,a)
{
	B[q] = getbinary(n);
	B'[p] = getbinary(n+1);
	m = 0;//保存插入元素后，最后发生进位的位置
	if(p>q)
		m = q;
	else
		for(i=0;i<=q;i++)
		{
			if(B[i]==0&&B'[i]==1)
				m = i;
				break;
		}
	sort(A0+A1+...Am-1) in Am;
}
插入操作在最坏情况下，会导致最高位进位，此时，所有元素都要从原有数组中复制到新数组Ak中，并进行排序。现在分析排序过程的花费时间：
k = lg(n+1)
排序过程如下：
1.初始时，对插入的元素a和A0的元素排序，花费时间1
2.对a+A0，A1元素排序，花费最多MAX(|a+A0|，|A1|)的时间---- 2
3.对a+A0+A1和A2的元素排序，花费最多MAX（|a+A0+A1|,|A2|）--4
以此类推排序花费时间为1+2+2^2+....2^(k-1） = 2^k -1 = n。
最后还要将所有n个元素复制到Ak中，共花费T（n） = n+n+1 = 2n+1 = O(n)
因此最坏情况下插入代价为O（n）。
下面分析插入代价的摊还代价：
由最坏插入代价可知，当插入操作导致<nk-1,...n0>中的i位由0置为1时，其插入代价为2*(2^i-1)+1。(i∈[0,k-1])
而从空集插入到有n个元素时，第i个位置发生置1操作的次数为n/2^(i+1)。因此，第i个位置花费的总操作时间为
T（i）= [2*(2^i-1)+1]*n/2^(i+1)
      = Θ(n)
总代价为T（n） = ∑T（i） = Θ(nk) = Θ(nlgn)
摊还代价为Θ(nlgn)/n = Θ(lgn)	

c.讨论如何实现DELETE
DELETE操作理应来说是INSERT操作的逆操作，但是删除操作不需要对元素进行再排序，只需要进行分配即可。

17-3（摊还加权平衡树）题目长，略
a. 在某种意义上，一棵1/2平衡树达到了极限的平衡。给定任意一棵二叉搜索树中的一个结点x，证明：如何重建以x为根的子树，使得它变为1/2平衡的。你的算法运行时间应该为Θ（x.size），可以使用O（x.size）的辅助空间
先递归打印出所有以x为根的元素到数组中，按从小到大序，此过程花费Θ（x.size）时间，花费O（x.size）的辅助空间。
再递归打印出所有元素，每次选取第n/2的元素作为根节点，此过程花费Θ（x.size）时间。
总共花费Θ（x.size）时间，花费O（x.size）的辅助空间。

b. 证明：在一棵n个结点的α平衡二叉搜索树中执行一次搜索操作的最坏情况时间为O（lgn）。
对于α平衡二叉搜索树，其树高最高为k
则存在n*α^k = 1
k = - logα（x.size） (1/2<=α<1)
  = O(lgn)
因此，树高是O（lgn），则在α平衡二叉搜索树中执行一次搜索操作的最坏情况时间为O（lgn）。

c. 证明：任意二叉搜索树的势都是非负的，1/2平衡树的势为0。
对于任意二叉搜索树，必然存在Φ（T）=c∑△（x）= c∑|x.left.size-x.right.size|>=0。且只有1/2平衡树时△（x）=0，Φ（T）=0。
因此，任意二叉搜索树的势都是非负的，且1/2平衡树的势为0。

d. 假定m个单位的势够支付重建m结点子树的代价。相对于α来说，c应该多大才能使得重建一棵非α平衡的子树的摊还时间为O（1）。
当一棵树需要被重建时，其势为：
Φ（T）= c∑|x.left.size-x.right.size|>= c|(2α-1)m|（当左右结点均为1/2平衡树时，等号成立）
且Φ（T）>=m
因此，c>=1/(2α-1),最小值为1/(2α-1)时，能使得重建一棵非α平衡的子树的摊还时间为O（1）。

e. 证明：在一棵n结点的α平衡树中插入一个结点或删除一个结点的摊还时间为O（lgn）
对于任意一棵n结点的α平衡树，插入操作和删除操作若没有导致树重建，那么只花费O（lgn），如果导致树重建，那么其摊还代价也仅为O（1），因此每个操作的摊还时间均为O（lgn）。

17-4（重构红黑树的代价）题目长，略
a. 设计一个n结点的合法红黑树，使得调用RB-INSRET添加第n+1个结点会引起Ω（lgn）次颜色更改。然后设计一个n结点的合法的红黑树，使得调用RB-DELETE删除一个特定结点会引起Ω（lgn）次颜色更改。
当红黑树从根结点到插入位置的简单路径上是满载状态时（即全是红黑交替），调用RB-INSERT会导致从叶结点循环更改颜色至根结点，至少发生Ω（lgn）次颜色更改。当一棵红黑树的结点是全黑时，删除任意一个结点会导致黑高变化，此时颜色变化会循环至根结点，因此RB-DELETE删除一个特定结点会引起Ω（lgn）次颜色更改。

b. RB-INSERT-FIXUP和RB-DELETE-FIXUP的代码的主循环都处理一下终结性的情况，一旦遇到这些情况，会导致循环在常数次操作后终止。对于RB-INSERT-FIXUP和RB-DELETE-FIXUP中处理的各种情况，指出哪些是终结性的，哪些不是。
红黑树一章已有详细分析，略

c. 令T'表示对T应用RB-INSERT-FIXUP的情况1得到的结果，证明：Φ（T'）=Φ（T）-1
在一次情况1中，x.color = red, x.p.color =red, x.p.p.color = black, x.p.p.right/x.p.p.left = red
进行颜色更改后，x.colot = red, x.p.color =black, x.p.p.color = red, x.p.p.right/x.p.p.left = black
因此Φ（T'）=Φ（T）-1

d. 当使用RB-INSERT向一棵红黑树中插入一个结点时，我们可以将操作分解为三部分，列出RB-INSERT的第1~16行引起的结构性改变和势的变化，以及RB-INSERT-FIXUP的非终结性情况引起的变化和终结性情况引起的变化。
在RB-INSERT的第1~16行中，只发生了1次结构性变化，并且红色结点+1，因此势Φ（T'）=Φ（T）+1。
在RB-INSERT-FIXUP中：
case1非终结性情况中：每调用一次，Φ（T'）=Φ（T'）-1，结构性修改发生3次
case2中，势不发生变化
case3中，势不发生变化。结构性修改发生2次
当最后终结时，Φ（T'）=Φ（T'）或Φ（T'）=Φ（T'）-1，

e.使用d证明：任意一次RB-INSERT执行所导致的结构性修改的摊还次数为O（1）。
c' = c +Φ（T'）-Φ（T）
因为1单位的势可以支付任意三种情况引起的结构性修改的代价，则在非终结性情况case1中，势可以抵消结构性修改的代价，而其他情况最多发生常数次，因此：c' = c +Φ（T'）-Φ（T）=1+O（1） = O(1)

f.证明：对RB-INSERT-FIXUP的任意非终结情况，有Φ（T'）<=Φ（T）-1。证明：RB-INSERT-FIXUP的任意一次调用所引起的结构性修改的摊还次数为O（1）。
非终结情况为case1，每发生一次case1，计算得Φ（T'）=Φ（T）-1,因此对于非终结情况，有Φ（T'）<=Φ（T）-1
摊还次数为1的证明过程同d，略

g.证明：对RB-DELETE-FIXUP的任意非终结情况，有Φ（T'）<=Φ（T）-1。证明：RB-DELETE-FIXUP的任意一次调用所引起的结构性修改的摊还次数为O（1）。
略

h.证明：任意m个RB-INSERT-FIXUP和RB-DELETE-FIXUP操作构成的序列最坏情况下执行O（m）次结构性修改。
两种操作的结构性修改摊还代价均为O（1），m次操作则会执行O（m）次结构性修改

17-5（移至前端自组织列表的竞争分析）题目长，略
a. 证明：若启发式策略H预先不知道访问序列，那么利用H来处理访问序列§的最坏情况代价为Ch（§）=Ω（mn）
在最坏情况下：对于§中的每个元素的搜索代价均m，因此，总代价为Ch（§）=Ω（mn）

b.证明：如果§i使用移至前端策略在L中访问元素x，则ci = 2*rankL（x）-1
如果§i使用移至前端策略在L中访问元素x,搜索代价为rankL（x）,并且使用rank（x）-1次相邻元素置换操作实现移至前端。
因此，其代价为ci = 2*rankL（x）-1

c.在b中你证明了ci = 2*rankL（x）-1。现在证明ci' = rankL'（x）+ti'
证明方法同B，搜索代价为rankL'（x），转置代价为ti'。总代价ci' = rankL'（x）+ti'

d.证明：转置操作要么将势增加2，要么减少2。
转置操作只发生在相邻元素之间，逆序对的总数变化只发生在这两个元素之间，与其他元素无关。因此，其结果要么使逆序对＋1，要么使逆序对-1,，即要么将势增加2，要么减少2。

e.证明：rankL(x)=|A|+|B|+1且rankL'（x）=|A|+|C|+1。
依题意，A∪B：在L中位于x之前的元素；A∪C：在L'中位于x之前的元素。
因此，rankL(x)=|A|+|B|+1，rankL'（x）=|A|+|C|+1

f.证明：处理访问§i会引起势的变化，Φ（Li）-Φ（Li-1）<=2(|A|-|B|+ti'),其中ti'表示用启发式策略H处理访问§i期间执行的转置操作次数。
使用移至前段策略时，除了要查找的元素x以外，其他元素之间的相对序不会发生变化，因此仅考虑元素x与其他元素的相对序来判断势的变化。
设Φ（Li-1）=0，那么在将x移至首部后，与x存在逆序关系的元素为0,在此之前存在逆序对|B|+|C|,因此Φ（Li）=-2（|B|+|C|）
带入不等式中，变换得2|A|+2|C|+2ti'>=0,继续变换得2ci'-2>=0 
即证明ci'>=1，rankL'(x)中，至少搜索一次，因此ci'>=1显然成立，因此，Φ（Li）-Φ（Li-1）<=2(|A|-|B|+ti')成立。

g.证明：处理访问§i的摊还代价上界为4ci'
ci^ = ci+Φ（Li）-Φ（Li-1）<= 2*rankL（x）-1+2(|A|-|B|+ti')
    = 2(|A|+|B|+1)-1+2(|A|-|B|+ti')=4|A|+2ti'+1
即证4|A|+2ti'+1<=4ci'
=》4|A|+2ti'+1<=4（|A|+|C|+1）+4ti'
=》2ti'+4|C|+3>=0
ti>=0,|C|>=0,因此等式显然成立，因此处理访问§i的摊还代价上界为4ci'

h. 证明：使用移至前端策略处理访问序列§的代价Cmtf(§)至多是其他任何启发式策略H处理§的代价Ch（§）的4倍。假定两种启发式策略都是从相同的列表开始处理访问序列。
移至前段策略同样可以














			
		




