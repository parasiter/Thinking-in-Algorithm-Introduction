14-1 最大重叠点。假设我们希望记录一个区间集合的最大重叠点，即被最多数目区间所覆盖的那个点。
a. 证明：最大重叠点一定是其中一个区间的端点。
当两个或两个以上区间有共同重叠区时，该区域内存在的点有1个或+∞个。当我们需要找出最大重叠点形成的区间时，需要以端点为扫描线，获取其重叠数目最大的重叠区间。因此，无论如何，只要存在重叠区间，必然是由两个端点形成的闭合区间，或仅由一个端点组成。

b.设计一个数据结构，使得它能够有效的支持INTERCAL-INSERT,INTERVAL-DELETE,以及返回最大重叠点的FIND-POM操作。


14-2 Josephus排列
a. 假设m是常数，描述一个O（n）时间的算法，使得对于给定的n，能够输出（n，m）的Josephus排列。
选择基础结构为环形链表，即x1.next = x2,x2.next = x3 .... xn.next = x1;
对于m为常数,可进行m次查找，找到下一个要打印的数，并对前驱的next指针进行修改，每次打印花费时间O(1),总共需要时间O(n)。

b. 假设m不是常数，描述一个O(nlgn)时间的算法，使得对于给定的n，能够输出（n,m）-Josephus排列。
以一棵红黑树为基础结构，为每个结点添加额外属性，x.size，保存以本结点为根结点的树的大小。
在红黑树中，以T.min指向最小元素。每次查找第m个后继时，可在最多O（2lgn）的时间内找到（最多向上循环一个树高，向下循环一个树高），打印m，并删除m，维护红黑树结构。

